// Copyright 2014-present Bill Fisher. All rights reserved.

#include "ofp/unittest.h"
#include "ofp/matchpacket.h"

using namespace ofp;

static void testPacket(const char *hex, const char *outHex) {
  std::string pkt = HexToRawData(hex);

  // Make sure that packet is aligned to a byte boundary as expected.
  // (Bypass Short-String Optimization)
  if (!IsPtrAligned(pkt.data(), 8))
    pkt.reserve(256);

  ASSERT_TRUE(IsPtrAligned(pkt.data(), 8));

  // Insert two zero bytes at the beginning of the data. MatchPacket expects
  // packet data to be aligned at 2 bytes *past* the 8-byte alignment. The
  // actual value of the two bytes is irrelevant.
  pkt.insert(0, "xx", 2);

  MatchPacket match{ByteRange{pkt.data() + 2, pkt.size() - 2}};
  EXPECT_HEX(outHex, match.data(), match.size());
}

TEST(matchpacket, ethernet) {
  testPacket("FFFFFFFFFFFF0000000000010806",
             "80000606:FFFFFFFFFFFF 80000806:000000000001 80000A02:0806");
}

TEST(matchpacket, arp) {
  testPacket(
      "FFFFFFFFFFFF000000000001080600010800060400010000000000010A00000100000000"
      "00000A000002",
      "80000606:FFFFFFFFFFFF 80000806:000000000001 80000A02:0806 80002A02:0001 "
      "80002C04:0A000001 80002E04:0A000002 80003006:000000000001 "
      "80003206:000000000000");
}

TEST(matchpacket, tcpv4) {
  testPacket(
      "1111111111112222222222220800 "
      "45334444555500007706888899999999AAAAAAAA "
      "BBBBCCCCDDDDDDDDDDDDDDDDEEEEFFFFFFFFFFFF",
      "80000606:111111111111 80000806:222222222222 80000A02:0800 80001001:0C "
      "80001201:03 80001401:06 80001604:99999999 80001804:AAAAAAAA 00013A01:77 "
      "80001A02:BBBB 80001C02:CCCC 00014402:0EEE");
}

TEST(matchpacket, udpv4) {
  testPacket(
      "1111111111112222222222220800 "
      "45334444555500007711888899999999AAAAAAAA BBBBCCCCDDDDEEEE",
      "80000606:111111111111 80000806:222222222222 80000A02:0800 80001001:0C "
      "80001201:03 80001401:11 80001604:99999999 80001804:AAAAAAAA 00013A01:77 "
      "80001E02:BBBB 80002002:CCCC");
}

TEST(matchpacket, icmpv4) {
  testPacket(
      "1111111111112222222222220800 "
      "45334444555500007701888899999999AAAAAAAA BBCCDDDDDDDD",
      "80000606:111111111111 80000806:222222222222 80000A02:0800 80001001:0C "
      "80001201:03 80001401:01 80001604:99999999 80001804:AAAAAAAA 00013A01:77 "
      "80002601:BB 80002801:CC");
}

TEST(matchpacket, icmpv6) {
  testPacket(
      "3333FF718C4C32FA25D4234186DD6000000000183AFF0000000000000000000000000000"
      "0000FF0200000000000000000001FF718C4C87009A9E00000000FE80000000000000FC0C"
      "CDFFFE718C4C",
      "80000606:3333FF718C4C 80000806:32FA25D42341 80000A02:86DD 80001001:00 "
      "80001201:00 80001401:3A 80003410:00000000000000000000000000000000 "
      "80003610:FF0200000000000000000001FF718C4C 80003804:00000000 80003A01:87 "
      "80003C01:00 80004E02:0001");
}

TEST(matchpacket, udpv6) {
  testPacket(
      "11111111111122222222222286DD "
      "633444445555116677777777777777777777777777777777888888888888888888888888"
      "88888888 BBBBCCCCDDDDEEEE",
      "80000606:111111111111 80000806:222222222222 80000A02:86DD 80001001:0C "
      "80001201:03 80001401:11 80003410:77777777777777777777777777777777 "
      "80003610:88888888888888888888888888888888 80003804:00044444 "
      "80001E02:BBBB 80002002:CCCC 80004E02:0001");
}

TEST(matchpacket, lldp) {
  testPacket(
      "0180C200000E00000000000188CC0207040000000000010403072D32060200780A1A4F46"
      "7C30303A30303A30303A30303A30303A30303A30303A3031FE240026E1004F467C2D3240"
      "4F467C30303A30303A30303A30303A30303A30303A30303A30310000",
      "800006060180C200000E8000080600000000000180000A0288CCFFFF024400FFFFFF0704"
      "000000000001000000000000000000000000000000000000000000000000000000000000"
      "0000000000000000000000000000000000000000000000000000FFFF044400FFFFFF0307"
      "2D3200000000000000000000000000000000000000000000000000000000000000000000"
      "0000000000000000000000000000000000000000000000000000FFFF060600FFFFFF007"
      "8");
}
