--- YAMLTraits.h	2015-03-10 15:56:21.000000000 -0700
+++ YAMLTraits.h	2015-03-21 10:24:41.000000000 -0700
@@ -20,7 +20,7 @@
 #include "llvm/ADT/StringSwitch.h"
 #include "llvm/ADT/Twine.h"
 #include "llvm/Support/Compiler.h"
-#include "llvm/Support/Regex.h"
+//#include "llvm/Support/Regex.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/YAMLParser.h"
 #include "llvm/Support/raw_ostream.h"
@@ -219,6 +219,20 @@
       (sizeof(test<ScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);
 };
 
+// Test if ScalarTraits<T>::json_type exists and is a primitive type.
+template <class T>
+struct has_ScalarJsonTraits
+{
+  template <typename U>
+  static char test(typename U::json_type *);
+
+  template <typename U>
+  static double test(...);
+
+public:
+  static bool const value = (sizeof(test<ScalarTraits<T>>(nullptr)) == 1);
+};
+
 
 // Test if MappingTraits<T> is defined on type T.
 template <class T>
@@ -270,6 +284,20 @@
   static bool const value =  (sizeof(test<SequenceTraits<T> >(nullptr)) == 1);
 };
 
+// Test if SequenceTraits<T> is defined on type T, with an iterator
+// type, and begin, end methods.
+template <class T>
+struct has_IteratorMethodTraits
+{
+  template <typename U>
+  static char test(typename U::iterator *);
+
+  template <typename U>
+  static double test(...);
+
+public:
+  static bool const value = (sizeof(test<SequenceTraits<T>>(nullptr)) == 1);
+};
 
 // has_FlowTraits<int> will cause an error with some compilers because
 // it subclasses int.  Using this wrapper only instantiates the
@@ -305,7 +333,8 @@
 // Test if SequenceTraits<T> is defined on type T
 template<typename T>
 struct has_SequenceTraits : public std::integral_constant<bool,
-                                      has_SequenceMethodTraits<T>::value > { };
+                                      has_SequenceMethodTraits<T>::value ||
+                                      has_IteratorMethodTraits<T>::value> { };
 
 
 // Test if DocumentListTraits<T> is defined on type T
@@ -324,6 +353,53 @@
   static bool const value = (sizeof(test<DocumentListTraits<T> >(nullptr))==1);
 };
 
+// Replace regex "^(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?$"
+inline bool isFloat(StringRef S) {
+  bool digitSeen = false;
+  bool dotSeen = false;
+  bool expSeen = false;
+  auto iter = S.begin();
+  auto iterEnd = S.end();
+
+  // Scan sequence of digits optionally containing a period
+  while (iter < iterEnd) {
+    char ch = *iter++;
+    if (isdigit(ch)) {
+      digitSeen = true;
+    } else if (ch == '.' && !dotSeen) {
+      dotSeen = true;
+    } else if (ch == 'e' || ch == 'E') { 
+      expSeen = true; 
+      break; 
+    } else 
+      return false;
+  }
+
+  assert(expSeen || iter == iterEnd);
+
+  if (!digitSeen)
+    return false;
+  if (!expSeen)
+    return true;
+  if (iter == iterEnd) 
+    return false;
+
+  // Scan exponent
+  if (*iter == '+' || *iter == '-') {
+    if (++iter == iterEnd)
+      return false;
+  }
+
+  assert(iter != iterEnd);
+
+  while (iter < iterEnd) {
+    if (!isdigit(*iter++)) 
+      return false;
+  }
+
+  return true;
+}
+
 inline bool isNumber(StringRef S) {
   static const char OctalChars[] = "01234567";
   if (S.startswith("0") &&
@@ -346,8 +422,7 @@
   if (S.equals(".inf") || S.equals(".Inf") || S.equals(".INF"))
     return true;
 
-  Regex FloatMatcher("^(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?$");
-  if (FloatMatcher.match(S))
+  if (isFloat(S))
     return true;
 
   return false;
@@ -427,6 +502,7 @@
   virtual ~IO();
 
   virtual bool outputting() = 0;
+  virtual bool outputtingJson() { return false; }
 
   virtual unsigned beginSequence() = 0;
   virtual bool preflightElement(unsigned, void *&) = 0;
@@ -453,8 +529,10 @@
   virtual bool beginBitSetScalar(bool &) = 0;
   virtual bool bitSetMatch(const char*, bool) = 0;
   virtual void endBitSetScalar() = 0;
+  virtual bool bitSetMatchOther(uint32_t &) = 0;
 
   virtual void scalarString(StringRef &, bool) = 0;
+  virtual void scalarJson(StringRef) {}
 
   virtual void setError(const Twine &) = 0;
 
@@ -511,6 +589,15 @@
       Val = Val | ConstVal;
   }
 
+  template <typename T>
+  void bitSetCaseOther(T &Val, T Mask) {
+    uint32_t Temp = Val;
+    if (outputting()) 
+      Temp &= Mask;
+    if (bitSetMatchOther(Temp))
+      Val = static_cast<T>(Val | Temp);
+  }
+
   void *getContext();
   void setContext(void *);
 
@@ -618,9 +705,45 @@
   }
 }
 
+template<typename T>
+inline std::string primitive_to_json(T value) {
+  return std::to_string(value);
+}
+
+template<>
+inline std::string primitive_to_json(bool value) {
+  return value ? "true" : "false";
+}
+
+template<typename T>
+typename std::enable_if<has_ScalarTraits<T>::value && has_ScalarJsonTraits<T>::value,void>::type
+yamlize(IO &io, T &Val, bool) {
+  if ( io.outputting() ) {
+    // Handle integer types differently on output to Json.
+    if (io.outputtingJson()) {
+      typename ScalarTraits<T>::json_type u = Val;
+      std::string Storage = primitive_to_json(u);
+      io.scalarJson(Storage);
+    } else {
+      llvm::SmallString<128> Storage;
+      llvm::raw_svector_ostream Buffer(Storage);
+      ScalarTraits<T>::output(Val, io.getContext(), Buffer);
+      StringRef Str = Buffer.str();
+      io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));
+    }
+  }
+  else {
+    StringRef Str;
+    io.scalarString(Str, false);  // call mustQuote on Input?
+    StringRef Result = ScalarTraits<T>::input(Str, io.getContext(), Val);
+    if ( !Result.empty() ) {
+      io.setError(llvm::Twine(Result));
+    }
+  }
+}
 
 template<typename T>
-typename std::enable_if<has_ScalarTraits<T>::value,void>::type
+typename std::enable_if<has_ScalarTraits<T>::value && !has_ScalarJsonTraits<T>::value,void>::type
 yamlize(IO &io, T &Val, bool) {
   if ( io.outputting() ) {
     std::string Storage;
@@ -675,7 +798,44 @@
 }
 
 template<typename T>
-typename std::enable_if<has_SequenceTraits<T>::value,void>::type
+T &mutable_ref(const T& ref) {
+  return const_cast<T&>(ref);
+}
+
+template<typename T>
+typename std::enable_if<has_IteratorMethodTraits<T>::value,void>::type
+yamlize(IO &io, T &Seq, bool) {
+  assert(io.outputting());
+  if ( has_FlowTraits< SequenceTraits<T> >::value ) {
+    unsigned incnt = io.beginFlowSequence();
+    typename SequenceTraits<T>::iterator iter = SequenceTraits<T>::begin(io, Seq);
+    typename SequenceTraits<T>::iterator iterEnd = SequenceTraits<T>::end(io, Seq);
+    for (; iter < iterEnd; SequenceTraits<T>::next(iter, iterEnd)) {
+      void *SaveInfo;
+      if ( io.preflightFlowElement(0, SaveInfo) ) {
+        yamlize(io, mutable_ref(*iter), true);
+        io.postflightFlowElement(SaveInfo);
+      }
+    }
+    io.endFlowSequence();
+  }
+  else {
+    unsigned incnt = io.beginSequence();
+    typename SequenceTraits<T>::iterator iter = SequenceTraits<T>::begin(io, Seq);
+    typename SequenceTraits<T>::iterator iterEnd = SequenceTraits<T>::end(io, Seq);
+    for (; iter < iterEnd; SequenceTraits<T>::next(iter, iterEnd)) {
+      void *SaveInfo;
+      if ( io.preflightElement(0, SaveInfo) ) {
+        yamlize(io, mutable_ref(*iter), true);
+        io.postflightElement(SaveInfo);
+      }
+    }
+    io.endSequence();
+  }
+}
+
+template<typename T>
+typename std::enable_if<has_SequenceMethodTraits<T>::value,void>::type
 yamlize(IO &io, T &Seq, bool) {
   if ( has_FlowTraits< SequenceTraits<T> >::value ) {
     unsigned incnt = io.beginFlowSequence();
@@ -709,6 +869,7 @@
   static void output(const bool &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, bool &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = bool;
 };
 
 template<>
@@ -730,6 +891,7 @@
   static void output(const uint8_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, uint8_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint8_t;
 };
 
 template<>
@@ -737,6 +899,7 @@
   static void output(const uint16_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, uint16_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint16_t;
 };
 
 template<>
@@ -744,6 +907,7 @@
   static void output(const uint32_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, uint32_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint32_t;
 };
 
 template<>
@@ -751,6 +915,7 @@
   static void output(const uint64_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, uint64_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint64_t;
 };
 
 template<>
@@ -758,6 +923,7 @@
   static void output(const int8_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, int8_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = int8_t;
 };
 
 template<>
@@ -765,6 +931,7 @@
   static void output(const int16_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, int16_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = int16_t;
 };
 
 template<>
@@ -772,6 +939,7 @@
   static void output(const int32_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, int32_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = int32_t;
 };
 
 template<>
@@ -779,6 +947,7 @@
   static void output(const int64_t &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, int64_t &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = int64_t;
 };
 
 template<>
@@ -786,6 +955,7 @@
   static void output(const float &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, float &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = float;
 };
 
 template<>
@@ -793,6 +963,7 @@
   static void output(const double &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, double &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = double;
 };
 
 
@@ -915,6 +1086,7 @@
   bool beginBitSetScalar(bool &) override;
   bool bitSetMatch(const char *, bool ) override;
   void endBitSetScalar() override;
+  bool bitSetMatchOther(uint32_t &) override;
   void scalarString(StringRef &, bool) override;
   void setError(const Twine &message) override;
   bool canElideEmptySequence() override;
@@ -1043,6 +1215,7 @@
   bool beginBitSetScalar(bool &) override;
   bool bitSetMatch(const char *, bool ) override;
   void endBitSetScalar() override;
+  bool bitSetMatchOther(uint32_t &) override;
   void scalarString(StringRef &, bool) override;
   void setError(const Twine &message) override;
   bool canElideEmptySequence() override;
@@ -1115,6 +1288,7 @@
   static void output(const Hex8 &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, Hex8 &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint8_t;
 };
 
 template<>
@@ -1122,6 +1296,7 @@
   static void output(const Hex16 &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, Hex16 &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint16_t;
 };
 
 template<>
@@ -1129,6 +1304,7 @@
   static void output(const Hex32 &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, Hex32 &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint32_t;
 };
 
 template<>
@@ -1136,6 +1312,7 @@
   static void output(const Hex64 &, void*, llvm::raw_ostream &);
   static StringRef input(StringRef, void*, Hex64 &);
   static bool mustQuote(StringRef) { return false; }
+  using json_type = uint64_t;
 };
 
 
