--- ../../../llvm_git/llvm/lib/Support/YAMLTraits.cpp	2017-12-09 16:02:39.000000000 -0700
+++ ./src/Support/YAMLTraits.cpp	2017-12-15 16:08:08.000000000 -0700
@@ -330,6 +330,45 @@
   }
 }
 
+bool Input::bitSetMatchOther(uint32_t &Val) {
+  if (EC)
+    return false;
+  if (SequenceHNode *SQ = dyn_cast<SequenceHNode>(CurrentNode)) {
+    unsigned Index = 0;
+    for (auto &N : SQ->Entries) {
+      if (ScalarHNode *SN = dyn_cast<ScalarHNode>(N.get())) {
+        StringRef S = SN->value();
+        if (!S.empty() && isdigit(S.front()) && !S.getAsInteger(0, Val)) {
+          BitValuesUsed[Index] = true;
+          return true;
+        }
+      } else {
+        setError(CurrentNode, "unexpected scalar in sequence of bit values");
+      }
+      ++Index;
+    }
+  } else {
+    setError(CurrentNode, "expected sequence of bit values");
+  }
+  return false;
+}
+
+StringRef Input::bitSetCaseUnmatched() {
+  if (EC)
+    return "";
+  SequenceHNode *SQ = dyn_cast<SequenceHNode>(CurrentNode);
+  if (!SQ)
+    return "";
+  assert(BitValuesUsed.size() == SQ->Entries.size());
+  for (unsigned i = 0; i < SQ->Entries.size(); ++i) {
+    if (!BitValuesUsed[i]) {
+      if (ScalarHNode *SN = dyn_cast<ScalarHNode>(SQ->Entries[i].get()))
+        return SN->value();
+    }
+  }
+  return "";
+}
+
 void Input::scalarString(StringRef &S, bool) {
   if (ScalarHNode *SN = dyn_cast<ScalarHNode>(CurrentNode)) {
     S = SN->value();
@@ -617,6 +656,23 @@
   this->outputUpToEndOfLine(" ]");
 }
 
+
+bool Output::bitSetMatchOther(uint32_t &Val) {
+  if (Val != 0) {
+    if (NeedBitValueComma)
+      output(", ");
+    char buf[16];
+    auto len = format("'0x%08X'", Val).print(buf, sizeof(buf));
+    this->output(StringRef{buf, len});
+    NeedBitValueComma = true;
+  }
+  return false;
+}
+
+StringRef Output::bitSetCaseUnmatched() {
+  return "";
+}
+
 void Output::scalarString(StringRef &S, bool MustQuote) {
   this->newLineCheck();
   if (S.empty()) {
