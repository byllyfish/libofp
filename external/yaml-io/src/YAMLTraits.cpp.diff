--- YAMLTraits.cpp	2015-01-18 12:39:20.000000000 -0700
+++ YAMLTraits.cpp	2015-01-18 12:43:02.000000000 -0700
@@ -291,6 +291,29 @@
   }
 }
 
+bool Input::bitSetMatchOther(uint32_t &Val) {
+  if (EC)
+    return false;
+  if (SequenceHNode *SQ = dyn_cast<SequenceHNode>(CurrentNode)) {
+    unsigned Index = 0;
+    for (auto &N : SQ->Entries) {
+      if (ScalarHNode *SN = dyn_cast<ScalarHNode>(N.get())) {
+        StringRef S = SN->value();
+        if (!S.empty() && isdigit(S.front()) && !S.getAsInteger(0, Val)) {
+          BitValuesUsed[Index] = true;
+          return true;
+        }
+      } else {
+        setError(CurrentNode, "unexpected scalar in sequence of bit values");
+      }
+      ++Index;
+    }
+  } else {
+    setError(CurrentNode, "expected sequence of bit values");
+  }
+  return false;
+}
+
 void Input::scalarString(StringRef &S, bool) {
   if (ScalarHNode *SN = dyn_cast<ScalarHNode>(CurrentNode)) {
     S = SN->value();
@@ -348,7 +371,13 @@
         memcpy(Buf, &StringStorage[0], Len);
         KeyStr = StringRef(Buf, Len);
       }
-      auto ValueHNode = this->createHNodes(KVN.getValue());
+      Node *ValueNode = KVN.getValue();
+      if (!ValueNode) {
+        assert(Strm->failed() && "Root is NULL iff parsing failed");
+        EC = make_error_code(errc::invalid_argument);
+        break;
+      }
+      auto ValueHNode = this->createHNodes(ValueNode);
       if (EC)
         break;
       mapHNode->Mapping[KeyStr] = std::move(ValueHNode);
@@ -540,6 +569,19 @@
   this->outputUpToEndOfLine(" ]");
 }
 
+
+bool Output::bitSetMatchOther(uint32_t &Val) {
+  if (Val != 0) {
+    if (NeedBitValueComma)
+      output(", ");
+    char buf[16];
+    auto len = format("'0x%08X'", Val).print(buf, sizeof(buf));
+    this->output(StringRef{buf, len});
+    NeedBitValueComma = true;
+  }
+  return false;
+}
+
 void Output::scalarString(StringRef &S, bool MustQuote) {
   this->newLineCheck();
   if (S.empty()) {
