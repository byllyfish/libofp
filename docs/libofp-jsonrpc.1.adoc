// To make the manpage using asciidoc, use the following command:
//
//   a2x --doctype manpage --format manpage libofp-jsonrpc.1.adoc
// 
// Use asciidoctor to produce the html version:
// 
//   asciidoctor libofp-jsonrpc.1.adoc

= LIBOFP-JSONRPC(1)
Bill Fisher <william.w.fisher@gmail.com>
:doctype: manpage
:github: <https://github.com/byllyfish/libofp>

== NAME

libofp-jsonrpc - OpenFlow Microservice


== SYNOPSIS

*libofp jsonrpc* [_OPTIONS_]


== DESCRIPTION

The *libofp jsonrpc* tool runs a JSON-RPC service that enables programmatic 
control of the OpenFlow protocol using JSON messages.

This program implements JSON-RPC 2.0 using a YAML 1.2 parser. Your JSON parser
must support 64 bit integers, or you will run into trouble handling large counters
and id's. 

This implementation ignores the "jsonrpc" property defined in the 
JSON-RPC 2.0 specification.

== OPTIONS

*--xpc*:: Run as an XPC service on Mac OS X.


== RPC Overview

The json-rpc server uses JSON-RPC protocol with some minor adjustments.

Request ID's must be non-negative integers less than or equal to 2^63-2.

There are seven JSON-RPC requests:

  - OFP.LISTEN
  - OFP.CONNECT
  - OFP.SEND
  - OFP.CLOSE
  - OFP.STATUS
  - OFP.LIST_CONNECTIONS
  - OFP.ADD_IDENTITY

There are three JSON-RPC notifications:

  - OFP.CHANNEL
  - OFP.MESSAGE
  - OFP.ALERT

If you omit the 'id' property from a request, no reply will be sent.

== RPC Commands

=== OFP.CONNECT

Open an outgoing OpenFlow connection to the specified host and port.

==== Request

    id: UInt64
    method: OFP.CONNECT
    params:
      endpoint: IPv6Endpoint
      versions: !opt [UInt8]
      tls_id:  !opt UInt64
      options: !opt [String]

*id*:: Request ID used to identify the reply (unsigned 64-bit integer).

*method*:: Must be "OFP.CONNECT".

*endpoint*:: Destination to connect to. Must be a string that specifies an 
    IPv4/IPv6 address and a TCP port number separated by a ':' or '.'. Formats 
    include: "127.0.0.1:6653", "127.0.0.1.6653", "[::1]:6653", "::1.6653".

*versions*:: List of OpenFlow versions to support. Defaults to all.

*tls_id*:: Identifier for TLS/DTLS identity to use. See ofp.add_identity.

*options*:: List of additional options that control the connection.
    - *--raw* = Raw mode; do not automatically send a features_request to determine the datapath_id.
    - *--udp* = Use UDP instead of TCP. This option must be combined with --raw.

==== Reply

    id: UInt64
    result:
        conn_id: UInt64

*conn_id*:: Connection ID associated with the new connection.

=== OFP.LISTEN

Listen for incoming OpenFlow connections on the specified interface and port.

==== Request 

    id: UInt64
    method: OFP.LISTEN
    params:
      endpoint: IPv6Endpoint
      versions: [UInt8]
      tls_id: UInt64
      options: [String]

*endpoint*:: Local IP address and port number to listen on, e.g. "127.0.0.1:8000".
    If the IP address is omitted, listen on all interface addresses. The IP 
    address and port number must be separated by a space or colon when both are 
    present. When using a colon separator, use brackets around an IPv6 address.

*versions*:: List of OpenFlow versions to support. Defaults to all.

*tls_id*:: TLS identity to use for securing the connection. The default identity is 0 (normally plaintext).

*options*:: List of boolean flags. The default is empty.
    - *raw* = Raw TCP mode; don't negotiate as a controller. Use this option to imitate an OpenFlow switch that listens for controller connections.

==== Reply

    id: UInt64
    result:
        conn_id: UInt64

*conn_id*:: Unique, non-zero identifier representing the listening connection.

==== Discussion

By default, this command listens for incoming connections from OpenFlow switches.
When a switch connects, we negotiate an OpenFlow connection and send a OpenFlow 
FeaturesRequest. The response to the FeaturesRequest is passed as the first 
ofp.message event.

When a TCP auxiliary connection arrives from a switch, the FeaturesReply is not
passed as a ofp.message.

This command will also listen for UDP auxiliary connections from switches.

If a non-zero tls_id is passed as an argument, we will use the specified TLS 
settings (see ofp.tls.add_identity) for TLS and DTLS.

There is one raw option for listen, raw_tcp. This option will listen for 
incoming connections on the specified TCP endpoint only (no UDP), negotiate 
an OpenFlow connection, but leave the rest of the connection alone.

=== OFP.SEND

Send the specified OpenFlow message.


==== Request

    id: UInt64
    method: OFP.SEND
    params: Message

==== Reply

    TODO

=== OFP.CLOSE

Close the specified connection.

==== Request

    id: UInt64
    method: OFP.CLOSE
    params:
      conn_id: UInt64

*conn_id*:: Specify the connection to close. Use 0 to close all connections.

==== Reply

    id: UInt64
    result:
      count: UInt64

*count*:: Number of connections closed.

=== OFP.LIST_CONNECTIONS

List all connections.

==== Request

    id: UInt64
    method: OFP.LIST_CONNECTIONS
    params:
      conn_id: UInt64

*conn_id*:: Specify a connection to obtain info for. Use 0 to list all connections.

==== Reply

    id: UInt64
    result: [{ConnectionInfo}...]

    {ConnectionInfo} ::=
      local_endpoint: IPv6Endpoint
      remote_endpoint: IPv6Endpoint
      datapath_id: DatapathID
      conn_id: UInt64
      auxiliary_id: UInt8
      transport: 'TCP' | 'UDP' | 'TLS' | 'DTLS' | 'NONE'

=== OFP.ADD_IDENTITY

Configure an identity for use in securing incoming or outgoing connections
using Transport Layer Security (TLS).

==== Request

    id: UInt64
    method: OFP.ADD_IDENTITY
    params:
      certificate: String
      verifier: String
      password: String                      # Optional; Default = ""

*certificate*:: PEM certificate chain data with PEM private key appended. The
  PEM private key may be encrypted with a password.

*verifier*:: Trusted PEM root certificate data.

*password*:: Password for PEM private key, if needed.

==== Reply

  id: UInt64
  result:
    tls_id: UInt64

*tls_id*:: Unique, non-zero identifier representing the TLS identity.

== RPC Notifications

=== OFP.CHANNEL

==== Request

  method: OFP.CHANNEL
  params:
    conn_id: UInt64
    datapath_id: DatapathID
    status: 'UP' | 'DOWN'
    version: UInt8

=== OFP.MESSAGE

  method: OFP.MESSAGE
  params: {Message}

=== ofp.message_error

  method: 'ofp.message_error'
  params:
    datapath_id: DatapathID
    error: String
    data: HexString

== TRANSPORT PROTOCOL

JSON-RPC messages are sent over a connection using a UTF-8 text protocol. Each
JSON message is separated by a newline. The maximum length of a line is 1 MB.

  { "id": 1, "method": "ofp.description" }

All responses are encoded in compact, single-line JSON representation.

  {"id":1,"result":{"major_version":0,"minor_version":1, ... }}

JSON input can also use YAML encoding, which is less stringent.
Still, no newlines are allowed.

  { id: 1, method: ofp.description }

A message encoded inside a JSON string is parsed using YAML. Escape newlines
with "\n".

  "id: 1\nmethod: ofp.description"


== SEE ALSO

_libofp_(1), _libofp-schema_(1)

== EXIT STATUS

*0*::
    Success

*1*::
    Failure: Syntax or usage error in command line arguments.


== RESOURCES

GitHub: {github}

== COPYING

Copyright \(C) 2015 Bill Fisher. Free use of this software is
granted under the terms of the MIT Licence.
