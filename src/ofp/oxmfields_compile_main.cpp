#include <vector>
#include <string>
#include <iostream>
#include <sstream>

using namespace std;

static vector<string> SplitLine(const string &line, char delimiter);
static void Trim(string &s);

class OXMField {
public:
	enum { NumFields = 7 };

	explicit OXMField(const vector<string> fields) : fields_{fields} 
	{
		for (auto &f : fields_) {
			Trim(f);
		}
	}
	
	const string &name() const { return fields_.at(0); }
	const string &clas() const { return fields_.at(1); }
	const string &field() const { return fields_.at(2); }
	const string &bits() const { return fields_.at(3); }
	const string &valueType() const { return fields_.at(4); }
	const string &mask() const { return fields_.at(5); }
	const string &prereqs() const { return fields_.at(6); }
	
	bool hasPrereqs() const { return !prereqs().empty(); }
	
	void defineOXMValue(ostream &s)
	{
		s << "using " << name() << " = OXMValue<" << 
			clas() << "," <<
			field() << "," <<
			valueType() << "," <<
		    bits() << "," <<
			mask();
			
		if (hasPrereqs()) {
			s << ",&OXMPrereq_" << name();
		}
		
		s << ">;\n";
	}
	
	void declareGlobalPrereq(ostream &s)
	{
		s << "extern const OXMRange OXMPrereq_" << name() << ";\n";
	}
	
	void writeGlobalPrereq(ostream &s)
	{
		s << "  Prereq(\"" << name() << "\", " << prereqs() << ");\n";
	}
	
private:
	vector<string> fields_;
};


static vector<OXMField> ReadInput(istream &stream);
static void WriteHeaderFile(ostream &stream, vector<OXMField> &fields);
static void WriteSourceFile(ostream &stream, vector<OXMField> &fields);


int main(int argc, char **argv)
{
	vector<string> args{&argv[0], &argv[argc]};
	
	bool header = (args.size() > 1) && args[1] == "-h";
	
	auto fields = ReadInput(cin);
	if (header) {
		WriteHeaderFile(cout, fields);
	} else {
		WriteSourceFile(cout, fields);
	}
}


static vector<OXMField> ReadInput(istream &stream)
{
	vector<OXMField> records;
	
	int lineNum = 0;
	std::string line;
	while (std::getline(stream, line)) {
		if (++lineNum == 1)						// skip first line
			continue;
		auto fields = SplitLine(line, '\t');
		if (fields.size() >= OXMField::NumFields) {
			records.push_back(OXMField{fields});
		} else {
			cerr << "Ignored:" << lineNum << ": " << line << '\n';
		}
	}
	
	return records;
}


static void WriteHeaderFile(ostream &stream, vector<OXMField> &fields)
{
	stream << "// !! DO NOT EDIT THIS FILE!!\n";
	stream << "//\n";
	stream << "// This file is automatically generated during the build\n";
	stream << "// process. Please make your changes to `ofp/oxmfields.tab`.\n";
	stream << "\n";
	stream << "#include \"ofp/oxmrange.h\"\n";
	stream << "#include \"ofp/oxmvalue.h\"\n";
	stream << "#include \"ofp/enetaddress.h\"\n";
	stream << "#include \"ofp/ipv4address.h\"\n";
	stream << "#include \"ofp/ipv6address.h\"\n\n";
	
	stream << "namespace ofp {\n";
	
	for (auto field : fields) {
		if (field.hasPrereqs())
			field.declareGlobalPrereq(stream);
	}
	
	stream << '\n';
	
	for (auto field : fields) {
		field.defineOXMValue(stream);
	}
	
	stream << '\n';
	stream << "}\n";
}


const char *PrereqFunctionPreamble = R"+++(

#include "ofp/oxmfields.h"
#include "ofp/oxmlist.h"
#include <iostream>

void WritePrereq(const char *name, const UInt *data, size_t len)
{
  cout << "static const UInt8 data_" << name << "[" << len << "]={";
  for (size_t i = 0; i < len; ++i) {
    cout << data[i] << ",";
  }
  cout << "};\n";
  cout << "ofp::OXMRange OXMPrereq_" << name << "{data_" << name << "," << len <<"};\n";
}

template <class T1, class T2>
void Prereq(const char *name, T1 a) {
  OXMList list;
  list.add(a);
  WritePrereq(name, list.data(), list.size());
}

template <class T1, class T2>
void Prereq(const char *name, T1 a, T2 c) {
  OXMList list;
  list.add(a);
  list.add(b);
  WritePrereq(name, list.data(), list.size());
}

template <class T1, class T2, class T3>
void Prereq(const char *name, T1 a, T2 c, T3 c) {
  OXMList list;
  list.add(a);
  list.add(b);
  list.add(c);
  WritePrereqFunction(name, list.data(), list.size());
}

)+++";


static void WriteSourceFile(ostream &stream, vector<OXMField> &fields)
{	
	stream << PrereqFunctionPreamble;
	stream << "int main() {\n";
	for (auto field : fields) {
		if (field.hasPrereqs())
			field.writeGlobalPrereq(stream);
	}
	stream << "}\n";
}


static vector<string> SplitLine(const string &line, char delimiter)
{
	vector<string> result;
	istringstream iss{line};
	for (string f; getline(iss, f, delimiter); ) {
		result.push_back(f);
	}
	return result;
}

static void Trim(string &s)
{
	auto first = s.find_first_not_of(" \t\n\v\f\r");
	if (first == string::npos) {
		s.clear();
	} else {
		s.erase(0, first);
		s.erase(s.find_last_not_of(" \t\n\v\f\r")+1);
	}
}

