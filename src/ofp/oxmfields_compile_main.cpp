#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <unordered_map>
#include <unordered_set>

using namespace std;

static vector<string> Split(const string &str, char delimiter, bool trim);

class OXMField {
public:
	enum { NumFields = 7 };

	explicit OXMField(const vector<string> fields) : fields_{fields} 
	{
	}
	
	const string &name() const { return fields_.at(0); }
	const string &clas() const { return fields_.at(1); }
	const string &field() const { return fields_.at(2); }
	const string &bits() const { return fields_.at(3); }
	const string &valueType() const { return fields_.at(4); }
	const string &mask() const { return fields_.at(5); }
	
	const string &prereqStr() const { return fields_.at(6); }
	string &prereqStr() { return fields_.at(6); }
	
	bool hasPrereqs() const { return !prereqStr().empty(); }
	
	vector<string> prereqs() const 
	{
		return Split(prereqStr(), ',', true);
	}
	
	void defineOXMValue(ostream &s)
	{
		s << "using " << name() << " = OXMValue<" << 
			clas() << "," <<
			field() << "," <<
			valueType() << "," <<
		    bits() << "," <<
			mask();
			
		if (hasPrereqs()) {
			s << ",&OXMPrereq_" << name();
		}
		
		s << ">;\n";
	}
	
	void declareGlobalPrereq(ostream &s)
	{
		s << "extern const OXMRange OXMPrereq_" << name() << ";\n";
	}
	
	void writePrereqCode(ostream &s)
	{
		s << "{\n";
		s << "OXMList list;\n";
		for (auto preq : prereqs()) {
			if (preq.find('&') != string::npos) {
				auto vec = Split(preq, '&', true);
				if (vec.size() == 2) {
					// Prereqs must be written twice. That's the signal.
					for (int i = 0; i < 2; ++i) 
						s << "list.addPrereq(" << vec[0] << "," << vec[1] << ");\n";
				} else {
					s << "/*\n";
					s << "$$$$$ Unexpected prereq: " << preq << '\n';
					s << "$$$$$ Aborting.\n";
					abort();
				}
			} else {
				s << "list.add(" << preq << ");\n";
			}
		}
		s << "WritePrereq(\"" << name() << "\", list.data(), list.size());\n";
		s << "}\n";
	}
	
private:
	vector<string> fields_;
};


static vector<OXMField> ReadInput(istream &stream);
static void WriteHeaderFile(ostream &stream, vector<OXMField> &fields);
static void WriteSourceFile(ostream &stream, vector<OXMField> &fields);
static void CompilePrereqs(vector<OXMField> &fields);


int main(int argc, char **argv)
{
	vector<string> args{argv, argv + argc};
	
	bool header = (args.size() > 1) && args[1] == "-h";
	
	auto fields = ReadInput(cin);
	if (header) {
		WriteHeaderFile(cout, fields);
	} else {
		CompilePrereqs(fields);
		WriteSourceFile(cout, fields);
	}
}


static vector<OXMField> ReadInput(istream &stream)
{
	vector<OXMField> records;
	
	int lineNum = 0;
	std::string line;
	while (std::getline(stream, line)) {
		if (++lineNum == 1)						// skip first line
			continue;
		auto fields = Split(line, '\t', true);
		if (fields.size() >= OXMField::NumFields) {
			records.push_back(OXMField{fields});
		} else {
			cerr << "Ignored:" << lineNum << ": " << line << '\n';
		}
	}
	
	return records;
}


static void WriteHeaderFile(ostream &stream, vector<OXMField> &fields)
{
	stream << "// !! DO NOT EDIT THIS FILE!!\n";
	stream << "//\n";
	stream << "// This file is automatically generated during the build\n";
	stream << "// process. Please make your changes to `ofp/oxmfields.tab`.\n";
	stream << "\n";
	stream << "#include \"ofp/oxmrange.h\"\n";
	stream << "#include \"ofp/oxmvalue.h\"\n";
	stream << "#include \"ofp/enetaddress.h\"\n";
	stream << "#include \"ofp/ipv4address.h\"\n";
	stream << "#include \"ofp/ipv6address.h\"\n\n";
	
	stream << "namespace ofp {\n";
	
	for (auto field : fields) {
		if (field.hasPrereqs())
			field.declareGlobalPrereq(stream);
	}
	
	stream << '\n';
	
	for (auto field : fields) {
		field.defineOXMValue(stream);
	}
	
	stream << '\n';
	stream << "}\n";
}


const char *PrereqFunctionPreamble = R"""(

#include "ofp/oxmfields.h"
#include "ofp/oxmlist.h"
#include <iostream>

using namespace ofp;

static void WritePrereq(const char *name, const UInt8 *data, size_t len)
{
  std::cout << "static const ofp::UInt8 data_" << name << "[" << len << "]={";
  for (size_t i = 0; i < len; ++i) {
    std::cout << unsigned(data[i]) << ",";
  }
  std::cout << "};\n";
  std::cout << "const ofp::OXMRange ofp::OXMPrereq_" << name << "{data_" << name << "," << len <<"};\n";
}

int main() {
  std::cout << "#include \"ofp/oxmfields.h\"\n";
  
)""";


static void WriteSourceFile(ostream &stream, vector<OXMField> &fields)
{	
	stream << PrereqFunctionPreamble;
	
	for (auto field : fields) {
		if (field.hasPrereqs())
			field.writePrereqCode(stream);
	}
	stream << "}\n";
}


static string Identifier(const string &s)
{
	auto first = s.find_first_of(" {[(&");
	return s.substr(0, first);
}


// Compile prerequisites.
static void CompilePrereqs(vector<OXMField> &fields)
{
	unordered_map<string,const OXMField*> map;
	
	for (auto &field : fields) {
		map[field.name()] = &field;
	}
	
	for (auto &field : fields) {
		vector<string> preqs = field.prereqs();
		// Find prereqStr for each preq and append it to preqresStr.
		unordered_set<string> processed;
		for (auto preq : preqs) {
			auto id = Identifier(preq);
			if (processed.find(id) == processed.end()) {
				processed.insert(id);
				auto pstr = map.find(id);
				if (pstr != map.end()) {
					if (pstr->second->hasPrereqs()) {
						field.prereqStr() = pstr->second->prereqStr() + ',' + field.prereqStr();
					}
				}
			}
		}
	}
}


static void Trim(string &s)
{
	auto first = s.find_first_not_of(" \t\n\v\f\r");
	if (first == string::npos) {
		s.clear();
	} else {
		s.erase(0, first);
		s.erase(s.find_last_not_of(" \t\n\v\f\r")+1);
	}
}

static vector<string> Split(const string &str, char delimiter, bool trim)
{
	vector<string> result;
	istringstream iss{str};
	for (string f; getline(iss, f, delimiter); ) {
		if (trim)
			Trim(f);
		result.push_back(f);
	}
	return result;
}

